/**
 * Export remediation guidance to Markdown format
 * Generates a comprehensive, downloadable file with all fixes for a scan
 */

import { getRemediationGuide } from './remediation-guide'

interface Issue {
  id: string
  rule: string
  description: string
  impact: string
  selector: string
  html?: string | null
  help_url?: string | null
}

interface ScanMetadata {
  scanId: string
  siteUrl: string
  siteName: string
  scanDate: string
  score: number
  totalIssues: number
}

/**
 * Generate a Markdown document with all remediation guidance
 */
export function generateRemediationMarkdown(
  issues: Issue[],
  metadata: ScanMetadata
): string {
  const { siteName, siteUrl, scanDate, score, totalIssues } = metadata

  // Group issues by rule (many issues can have the same rule)
  const issuesByRule = new Map<string, Issue[]>()
  issues.forEach(issue => {
    const existing = issuesByRule.get(issue.rule) || []
    issuesByRule.set(issue.rule, [...existing, issue])
  })

  const sections: string[] = []

  // Header
  sections.push(`# Accessibility Remediation Guide`)
  sections.push(``)
  sections.push(`**Site:** ${siteName}`)
  sections.push(`**URL:** ${siteUrl}`)
  sections.push(`**Scan Date:** ${new Date(scanDate).toLocaleDateString('en-US', { 
    year: 'numeric', 
    month: 'long', 
    day: 'numeric',
    hour: '2-digit',
    minute: '2-digit'
  })}`)
  sections.push(`**Accessibility Score:** ${score}%`)
  sections.push(`**Total Issues:** ${totalIssues}`)
  sections.push(``)
  sections.push(`---`)
  sections.push(``)

  // Table of Contents
  sections.push(`## 📋 Table of Contents`)
  sections.push(``)
  let issueIndex = 1
  issuesByRule.forEach((issuesForRule, rule) => {
    const guide = getRemediationGuide(rule)
    sections.push(`${issueIndex}. [${guide.title}](#${issueIndex}-${slugify(guide.title)}) (${issuesForRule.length} instance${issuesForRule.length > 1 ? 's' : ''})`)
    issueIndex++
  })
  sections.push(``)
  sections.push(`---`)
  sections.push(``)

  // Detailed sections for each unique rule
  issueIndex = 1
  issuesByRule.forEach((issuesForRule, rule) => {
    const guide = getRemediationGuide(rule)
    const firstIssue = issuesForRule[0]

    sections.push(`## ${issueIndex}. ${guide.title}`)
    sections.push(``)
    sections.push(`**Rule:** \`${rule}\``)
    sections.push(`**Impact:** ${firstIssue.impact}`)
    sections.push(`**Instances Found:** ${issuesForRule.length}`)
    sections.push(``)

    // Description
    sections.push(`### 📝 Issue Description`)
    sections.push(``)
    sections.push(guide.description)
    sections.push(``)

    // Steps to Fix
    sections.push(`### ✅ How to Fix`)
    sections.push(``)
    guide.steps.forEach((step, idx) => {
      sections.push(`${idx + 1}. ${step}`)
    })
    sections.push(``)

    // Code Example
    if (guide.codeExample) {
      sections.push(`### 💻 Code Example`)
      sections.push(``)
      sections.push('```html')
      sections.push(guide.codeExample)
      sections.push('```')
      sections.push(``)
    }

    // WCAG Reference
    sections.push(`### 📚 WCAG Reference`)
    sections.push(``)
    sections.push(`**Standard:** ${guide.wcagCriteria}`)
    if (firstIssue.help_url) {
      sections.push(`**Documentation:** ${firstIssue.help_url}`)
    }
    sections.push(``)

    // Affected Elements
    sections.push(`### 🎯 Affected Elements (${issuesForRule.length})`)
    sections.push(``)
    issuesForRule.forEach((issue, idx) => {
      sections.push(`#### Instance ${idx + 1}`)
      sections.push(``)
      sections.push(`**Selector:**`)
      sections.push('```css')
      sections.push(issue.selector)
      sections.push('```')
      sections.push(``)
      
      if (issue.html) {
        sections.push(`**HTML:**`)
        sections.push('```html')
        sections.push(issue.html)
        sections.push('```')
        sections.push(``)
      }
    })

    sections.push(`---`)
    sections.push(``)
    issueIndex++
  })

  // Footer
  sections.push(`## 🔧 Additional Resources`)
  sections.push(``)
  sections.push(`- [WCAG 2.1 Quick Reference](https://www.w3.org/WAI/WCAG21/quickref/)`)
  sections.push(`- [W3C ARIA Authoring Practices](https://www.w3.org/WAI/ARIA/apg/)`)
  sections.push(`- [WebAIM Contrast Checker](https://webaim.org/resources/contrastchecker/)`)
  sections.push(`- [MDN Web Accessibility](https://developer.mozilla.org/en-US/docs/Web/Accessibility)`)
  sections.push(``)
  sections.push(`---`)
  sections.push(``)
  sections.push(`*Generated by Auditvia - https://auditvia.com*`)
  sections.push(`*Scan ID: ${metadata.scanId}*`)

  return sections.join('\n')
}

/**
 * Download the Markdown file
 */
export function downloadRemediationFile(
  markdown: string,
  siteName: string,
  scanDate: string
): void {
  const blob = new Blob([markdown], { type: 'text/markdown;charset=utf-8' })
  const url = URL.createObjectURL(blob)
  const link = document.createElement('a')
  
  // Generate filename: site-name-remediation-2024-01-15.md
  const dateStr = new Date(scanDate).toISOString().split('T')[0]
  const filename = `${slugify(siteName)}-remediation-${dateStr}.md`
  
  link.href = url
  link.download = filename
  document.body.appendChild(link)
  link.click()
  document.body.removeChild(link)
  URL.revokeObjectURL(url)
}

/**
 * Helper: Convert text to URL-friendly slug
 */
function slugify(text: string): string {
  return text
    .toLowerCase()
    .replace(/[^\w\s-]/g, '') // Remove non-word chars except spaces and hyphens
    .replace(/\s+/g, '-') // Replace spaces with hyphens
    .replace(/-+/g, '-') // Replace multiple hyphens with single hyphen
    .trim()
}

/**
 * Main export function - combines generation and download
 */
export function exportRemediationGuide(
  issues: Issue[],
  metadata: ScanMetadata
): void {
  const markdown = generateRemediationMarkdown(issues, metadata)
  downloadRemediationFile(markdown, metadata.siteName, metadata.scanDate)
}
