/**
 * GitHub Integration Client
 * Minimal client for creating GitHub Issues with accessibility violation details
 */

import { Octokit } from '@octokit/rest'

interface GitHubConfig {
  token: string
  owner: string
  repo: string
}

interface ViolationData {
  ruleId: string
  impact: 'critical' | 'serious' | 'moderate' | 'minor'
  selector: string
  html?: string
  description: string
  wcagTags: string[]
  wcagReference: string
  howToFixSteps: string[]
  codeExample?: string
}

interface CreateIssueParams {
  config: GitHubConfig
  violation: ViolationData
  siteUrl: string
  scanId: string
  reportUrl: string
  violationDetailUrl?: string
  mode?: 'issue_only' | 'pr'
}

/**
 * Create a GitHub client instance
 */
export function createGitHubClient(token: string): Octokit {
  return new Octokit({
    auth: token,
  })
}

/**
 * Format WCAG tags as markdown links
 */
function formatWCAGTags(tags: string[]): string {
  if (!tags || tags.length === 0) return 'N/A'
  
  return tags
    .map(tag => {
      // Convert tags like "wcag2aa" or "wcag412" to readable format
      const readable = tag.replace(/wcag/i, 'WCAG ').toUpperCase()
      return `[\`${tag}\`](https://www.w3.org/WAI/WCAG21/quickref/?tags=${tag})`
    })
    .join(' · ')
}

/**
 * Get impact emoji and label
 */
function getImpactDisplay(impact: string): { emoji: string; label: string } {
  switch (impact) {
    case 'critical':
      return { emoji: '🔴', label: 'Critical' }
    case 'serious':
      return { emoji: '🟠', label: 'Serious' }
    case 'moderate':
      return { emoji: '🟡', label: 'Moderate' }
    default:
      return { emoji: '⚪', label: 'Minor' }
  }
}

/**
 * Generate markdown body for GitHub Issue
 */
export function generateIssueBody(params: CreateIssueParams): string {
  const { violation, siteUrl, reportUrl, violationDetailUrl, mode = 'issue_only' } = params
  const impactDisplay = getImpactDisplay(violation.impact)
  
  let body = `## 🔍 Accessibility Issue Detected\n\n`
  
  // Summary section
  body += `**Impact:** ${impactDisplay.emoji} ${impactDisplay.label}\n`
  body += `**Site:** ${siteUrl}\n`
  body += `**Element:** \`${violation.selector}\`\n\n`
  
  // Description
  body += `### Description\n\n`
  body += `${violation.description}\n\n`
  
  // WCAG Compliance
  body += `### 📋 WCAG Compliance\n\n`
  body += `**Tags:** ${formatWCAGTags(violation.wcagTags)}\n`
  body += `**Reference:** ${violation.wcagReference}\n\n`
  
  // How to Fix
  body += `### 🔧 How to Fix\n\n`
  if (violation.howToFixSteps && violation.howToFixSteps.length > 0) {
    violation.howToFixSteps.forEach((step, index) => {
      body += `${index + 1}. ${step}\n`
    })
    body += `\n`
  }
  
  // Code Example
  if (violation.codeExample) {
    body += `### 💻 Code Example\n\n`
    body += `\`\`\`\n${violation.codeExample}\n\`\`\`\n\n`
  }
  
  // Technical Details
  body += `### 🔍 Technical Details\n\n`
  body += `**CSS Selector:**\n\`\`\`css\n${violation.selector}\n\`\`\`\n\n`
  
  if (violation.html) {
    body += `**HTML Snippet:**\n\`\`\`html\n${violation.html}\n\`\`\`\n\n`
  }
  
  // Link back to Auditvia report
  body += `---\n\n`
  
  if (violationDetailUrl) {
    body += `📊 **[View This Violation in Auditvia](${violationDetailUrl})**\n\n`
  }
  
  body += `📊 **[View Full Report in Auditvia](${reportUrl})**\n\n`
  
  // Add mode-specific footer
  if (mode === 'issue_only') {
    body += `> **Note:** This site is configured in **issue-only mode**. This is a tracking issue for an accessibility violation. `
    body += `To enable automated PR generation with code fixes, configure this site with a code repository in PR mode.\n\n`
  }
  
  body += `*This issue was automatically generated by [Auditvia](https://auditvia.com) - Accessibility Compliance Made Simple*\n`
  
  return body
}

/**
 * Create a GitHub Issue for an accessibility violation
 */
export async function createAccessibilityIssue(params: CreateIssueParams): Promise<{
  url: string
  number: number
}> {
  const { config, violation } = params
  const client = createGitHubClient(config.token)
  
  // Generate issue title
  const title = `Fix: ${violation.ruleId} at ${violation.selector.substring(0, 50)}${violation.selector.length > 50 ? '...' : ''}`
  
  // Generate issue body
  const body = generateIssueBody(params)
  
  // Build structured labels
  const labels = [
    'accessibility',
    `severity:${violation.impact}`,
    'auditvia'
  ]
  
  // Add WCAG-specific labels
  if (violation.wcagTags && violation.wcagTags.length > 0) {
    labels.push(`wcag:${violation.ruleId}`)
  }
  
  // Add mode label
  labels.push(`mode:${params.mode || 'issue_only'}`)
  
  // Create the issue
  const { data } = await client.issues.create({
    owner: config.owner,
    repo: config.repo,
    title,
    body,
    labels
  })
  
  return {
    url: data.html_url,
    number: data.number
  }
}

/**
 * Validate GitHub repository format (owner/repo)
 */
export function validateRepoFormat(repo: string): boolean {
  const repoRegex = /^[a-zA-Z0-9_-]+\/[a-zA-Z0-9_.-]+$/
  return repoRegex.test(repo)
}

/**
 * Parse owner/repo string into components
 */
export function parseRepoString(repo: string): { owner: string; repo: string } | null {
  if (!validateRepoFormat(repo)) {
    return null
  }
  
  const [owner, repoName] = repo.split('/')
  return { owner, repo: repoName }
}

/**
 * Verify GitHub token has required permissions
 */
export async function verifyGitHubToken(token: string): Promise<{
  valid: boolean
  scopes?: string[]
  error?: string
}> {
  try {
    const client = createGitHubClient(token)
    const { headers } = await client.request('GET /user')
    
    const scopes = headers['x-oauth-scopes']?.split(',').map(s => s.trim()) || []
    const hasRepoScope = scopes.includes('repo') || scopes.includes('public_repo')
    
    return {
      valid: hasRepoScope,
      scopes,
      error: hasRepoScope ? undefined : 'Token missing required "repo" scope'
    }
  } catch (error: any) {
    return {
      valid: false,
      error: error.message || 'Failed to verify token'
    }
  }
}

/**
 * Validate repository exists and is accessible
 */
export async function validateRepository(token: string, owner: string, repo: string): Promise<{
  valid: boolean
  exists?: boolean
  hasAccess?: boolean
  isPrivate?: boolean
  error?: string
}> {
  try {
    const client = createGitHubClient(token)
    
    const { data } = await client.repos.get({
      owner,
      repo
    })
    
    return {
      valid: true,
      exists: true,
      hasAccess: true,
      isPrivate: data.private
    }
  } catch (error: any) {
    if (error.status === 404) {
      return {
        valid: false,
        exists: false,
        hasAccess: false,
        error: 'Repository not found or you don\'t have access'
      }
    }
    
    if (error.status === 401 || error.status === 403) {
      return {
        valid: false,
        exists: true,
        hasAccess: false,
        error: 'Access denied. Please check your token permissions.'
      }
    }
    
    return {
      valid: false,
      error: error.message || 'Failed to validate repository'
    }
  }
}

/**
 * Validate token has required permissions for issue creation
 */
export async function validateTokenPermissions(token: string, owner: string, repo: string): Promise<{
  valid: boolean
  hasIssuesWrite?: boolean
  hasContentsRead?: boolean
  hasMetadataRead?: boolean
  scopes?: string[]
  error?: string
  code?: string
}> {
  try {
    const client = createGitHubClient(token)
    
    // First check if we can read the repo (metadata)
    const { data: repoData } = await client.repos.get({
      owner,
      repo
    })
    
    const hasMetadataRead = !!repoData
    
    // Check headers for OAuth scopes (classic tokens only)
    const { headers } = await client.request('GET /user')
    const scopes = headers['x-oauth-scopes']?.split(',').map(s => s.trim()) || []
    
    // For classic tokens, check for repo scope
    const hasRepoScope = scopes.includes('repo') || scopes.includes('public_repo')
    
    // Try to check repo permissions (works for both classic and fine-grained)
    let hasIssuesWrite = false
    let hasContentsRead = false
    
    try {
      // Check if we can access issues endpoint (read permission minimum)
      await client.issues.listForRepo({
        owner,
        repo,
        per_page: 1
      })
      
      // If we got here, we have at least issues:read
      // For write permission, we'd need to try creating (which we don't want to do in a check)
      // So we'll assume if we have repo scope OR issues:read, we likely have issues:write
      hasIssuesWrite = hasRepoScope || true // Conservative: assume we have write if we have read
      hasContentsRead = true
    } catch (error: any) {
      if (error.status === 403) {
        return {
          valid: false,
          hasIssuesWrite: false,
          hasContentsRead: false,
          hasMetadataRead,
          scopes,
          error: 'Token lacks required permissions for this repository',
          code: 'insufficient_permissions'
        }
      }
      throw error
    }
    
    if (!hasIssuesWrite) {
      return {
        valid: false,
        hasIssuesWrite: false,
        hasContentsRead,
        hasMetadataRead,
        scopes,
        error: 'Token requires Issues: write permission',
        code: 'insufficient_permissions'
      }
    }
    
    return {
      valid: true,
      hasIssuesWrite,
      hasContentsRead,
      hasMetadataRead,
      scopes
    }
  } catch (error: any) {
    if (error.status === 401) {
      return {
        valid: false,
        error: 'Invalid or expired token',
        code: 'invalid_token'
      }
    }
    
    if (error.status === 404) {
      return {
        valid: false,
        error: 'Repository not found or no access',
        code: 'repo_not_found'
      }
    }
    
    return {
      valid: false,
      error: error.message || 'Failed to validate token permissions',
      code: 'validation_failed'
    }
  }
}
