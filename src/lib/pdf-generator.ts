import { chromium, Browser } from 'playwright'
import { createClient } from '@supabase/supabase-js'
import type { Database } from '@/app/types/database'

// Supabase client for file storage
const supabase = createClient<Database>(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
)

export interface PDFGenerationOptions {
  scanId: string
  teamId: string
  userId: string
  format?: 'A4' | 'Letter'
  includeImages?: boolean
  timeout?: number
}

export interface PDFGenerationResult {
  success: boolean
  filePath?: string
  downloadUrl?: string
  error?: string
  fileSize?: number
}

class PDFGenerator {
  private browser: Browser | null = null
  
  async initialize(): Promise<void> {
    if (this.browser) return
    
    console.log('ðŸŽ¨ [pdf] Initializing Playwright browser...')
    this.browser = await chromium.launch({
      headless: true,
      args: [
        '--no-sandbox',
        '--disable-setuid-sandbox',
        '--disable-dev-shm-usage',
        '--disable-gpu',
        '--no-first-run',
        '--no-zygote',
        '--single-process',
      ]
    })
    console.log('ðŸŽ¨ [pdf] Browser initialized successfully')
  }

  async cleanup(): Promise<void> {
    if (this.browser) {
      await this.browser.close()
      this.browser = null
      console.log('ðŸŽ¨ [pdf] Browser cleaned up')
    }
  }

  async generatePDF(options: PDFGenerationOptions): Promise<PDFGenerationResult> {
    const { scanId, teamId, userId, format = 'A4', timeout = 30000 } = options
    
    console.log(`ðŸŽ¨ [pdf] Starting PDF generation for scan: ${scanId}`)
    
    try {
      await this.initialize()
      
      if (!this.browser) {
        throw new Error('Failed to initialize browser')
      }

      const page = await this.browser.newPage()
      
      try {
        // Set viewport for consistent rendering
        await page.setViewportSize({ width: 1200, height: 800 })
        
        // Generate auth token for PDF route access
        const authToken = await this.generateAuthToken(scanId, teamId, userId)
        
        // Navigate to PDF report page
        const pdfUrl = `${process.env.NEXTAUTH_URL}/report/${scanId}/pdf?token=${authToken}`
        console.log(`ðŸŽ¨ [pdf] Navigating to: ${pdfUrl}`)
        
        await page.goto(pdfUrl, { 
          waitUntil: 'networkidle',
          timeout 
        })
        
        // Wait for content to load
        await page.waitForSelector('.header', { timeout: 10000 })
        console.log('ðŸŽ¨ [pdf] Page content loaded')
        
        // Generate PDF
        const pdfBuffer = await page.pdf({
          format: format,
          printBackground: true,
          margin: {
            top: '20mm',
            right: '15mm',
            bottom: '20mm',
            left: '15mm'
          },
          displayHeaderFooter: true,
          headerTemplate: `
            <div style="font-size: 10px; color: #666; width: 100%; text-align: center; margin: 0 15mm;">
              <span>Accessibility Report - Generated by Auditvia</span>
            </div>
          `,
          footerTemplate: `
            <div style="font-size: 10px; color: #666; width: 100%; display: flex; justify-content: space-between; margin: 0 15mm;">
              <span>Confidential</span>
              <span>Page <span class="pageNumber"></span> of <span class="totalPages"></span></span>
              <span>${new Date().toLocaleDateString()}</span>
            </div>
          `,
          preferCSSPageSize: false,
        })
        
        console.log(`ðŸŽ¨ [pdf] PDF generated, size: ${pdfBuffer.length} bytes`)
        
        // Upload to Supabase Storage
        const fileName = `accessibility-report-${scanId}-${Date.now()}.pdf`
        const filePath = `reports/${teamId}/${fileName}`

        const { data: _uploadData, error: uploadError } = await supabase.storage
          .from('pdf-reports')
          .upload(filePath, pdfBuffer, {
            contentType: 'application/pdf',
            cacheControl: '3600',
            upsert: false
          })
        
        if (uploadError) {
          console.error('ðŸŽ¨ [pdf] Upload error:', uploadError)
          throw new Error(`Failed to upload PDF: ${uploadError.message}`)
        }
        
        console.log(`ðŸŽ¨ [pdf] PDF uploaded to: ${filePath}`)
        
        // Generate signed URL for download (valid for 1 hour)
        const { data: signedUrlData, error: urlError } = await supabase.storage
          .from('pdf-reports')
          .createSignedUrl(filePath, 3600)
        
        if (urlError) {
          console.error('ðŸŽ¨ [pdf] Signed URL error:', urlError)
          throw new Error(`Failed to create download URL: ${urlError.message}`)
        }
        
        console.log(`ðŸŽ¨ [pdf] âœ… PDF generation completed successfully`)
        
        return {
          success: true,
          filePath,
          downloadUrl: signedUrlData.signedUrl,
          fileSize: pdfBuffer.length
        }
        
      } finally {
        await page.close()
      }
      
    } catch (error) {
      console.error('ðŸŽ¨ [pdf] Generation failed:', error)
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error occurred'
      }
    }
  }

  private async generateAuthToken(scanId: string, teamId: string, userId: string): Promise<string> {
    // Simple JWT-like token for PDF access (you might want to use a proper JWT library)
    const payload = {
      scanId,
      teamId,
      userId,
      purpose: 'pdf-generation',
      exp: Date.now() + 300000 // 5 minutes
    }
    
    // In production, you'd want to sign this properly
    return Buffer.from(JSON.stringify(payload)).toString('base64')
  }
}

// Singleton instance
let pdfGenerator: PDFGenerator | null = null

export async function generateScanPDF(options: PDFGenerationOptions): Promise<PDFGenerationResult> {
  if (!pdfGenerator) {
    pdfGenerator = new PDFGenerator()
  }
  
  try {
    return await pdfGenerator.generatePDF(options)
  } finally {
    // Clean up browser after each generation to prevent memory leaks
    if (pdfGenerator) {
      await pdfGenerator.cleanup()
      pdfGenerator = null
    }
  }
}

// Utility function to validate PDF generation requirements
export function validatePDFRequest(scanId: string, teamId: string, userId: string): { valid: boolean; error?: string } {
  if (!scanId || typeof scanId !== 'string') {
    return { valid: false, error: 'Invalid scan ID' }
  }
  
  if (!teamId || typeof teamId !== 'string') {
    return { valid: false, error: 'Invalid team ID' }
  }
  
  if (!userId || typeof userId !== 'string') {
    return { valid: false, error: 'Invalid user ID' }
  }
  
  return { valid: true }
}

// Helper to estimate PDF generation time based on scan complexity
export function estimatePDFGenerationTime(issueCount: number): number {
  // Base time: 5 seconds
  // Additional time: 100ms per issue
  return Math.max(5000, 5000 + (issueCount * 100))
}
