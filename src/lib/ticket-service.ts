/**
 * Ticket Service
 * Handles ticket creation for GitHub and Jira integrations
 */

import { getRemediationGuide } from './remediation-guide'

// =====================================================
// Types
// =====================================================

export type TicketProvider = 'github' | 'jira'

export interface TicketProviderConfig {
  id: string
  team_id: string
  provider_type: TicketProvider
  config: GitHubConfig | JiraConfig
  encrypted_token: string
  is_active: boolean
}

export interface GitHubConfig {
  owner: string // Organization or user
  repo: string
  labels?: string[] // Default labels to apply
}

export interface JiraConfig {
  host: string // e.g., "company.atlassian.net"
  project_key: string // e.g., "PROJ"
  issue_type: string // e.g., "Bug", "Task"
}

export interface IssueGroup {
  rule: string // e.g., "color-contrast"
  impact: string // "critical", "serious", etc.
  description: string
  help_url: string
  count: number // Total instances
  instances: Array<{
    selector: string
    html: string
  }>
}

export interface TicketPayload {
  title: string
  body: string
  labels?: string[] // GitHub only
  issueType?: string // Jira only
}

export interface CreateTicketResult {
  success: boolean
  ticket_url?: string
  ticket_key?: string // GitHub: issue number, Jira: issue key
  error?: string
}

// =====================================================
// Ticket Formatting
// =====================================================

/**
 * Generate ticket title
 */
export function generateTicketTitle(
  siteName: string,
  rule: string,
  count: number
): string {
  const ruleLabel = rule
    .split('-')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ')
  
  return `[A11y] ${ruleLabel} - ${count} ${count === 1 ? 'issue' : 'issues'} on ${siteName}`
}

/**
 * Generate ticket body (Markdown format for both GitHub and Jira)
 */
export function generateTicketBody(
  siteUrl: string,
  scanId: string,
  reportUrl: string,
  issueGroup: IssueGroup
): string {
  const { rule, impact, description, help_url, count, instances } = issueGroup
  
  // Get remediation guidance
  const remediation = getRemediationGuide(rule)
  
  // Build ticket body
  const lines: string[] = []
  
  // Header
  lines.push(`## Accessibility Issue: ${rule}`)
  lines.push('')
  lines.push(`**Impact:** ${impact}`)
  lines.push(`**Instances:** ${count}`)
  lines.push(`**Site:** ${siteUrl}`)
  lines.push('')
  
  // Description
  lines.push(`### Description`)
  lines.push('')
  lines.push(description)
  lines.push('')
  
  // How to Fix
  lines.push(`### How to Fix`)
  lines.push('')
  lines.push(remediation.description)
  lines.push('')
  lines.push(`**Steps:**`)
  remediation.steps.forEach((step, i) => {
    lines.push(`${i + 1}. ${step}`)
  })
  lines.push('')
  
  // Code example if available
  if (remediation.codeExample) {
    lines.push(`**Example:**`)
    lines.push('```')
    lines.push(remediation.codeExample)
    lines.push('```')
    lines.push('')
  }
  
  // WCAG Reference
  lines.push(`**WCAG Criteria:** ${remediation.wcagCriteria}`)
  lines.push('')
  
  // Examples (top 3)
  const exampleCount = Math.min(3, instances.length)
  lines.push(`### Examples (showing ${exampleCount} of ${count})`)
  lines.push('')
  
  instances.slice(0, 3).forEach((instance, i) => {
    lines.push(`#### ${i + 1}. \`${truncate(instance.selector, 100)}\``)
    lines.push('')
    lines.push('```html')
    lines.push(truncate(instance.html, 300))
    lines.push('```')
    lines.push('')
  })
  
  // Resources
  lines.push(`### Resources`)
  lines.push('')
  lines.push(`- [Full scan report](${reportUrl})`)
  lines.push(`- [WCAG Guidelines](${help_url})`)
  lines.push('')
  
  // Footer
  lines.push(`---`)
  lines.push(`*Generated by Auditvia from scan [\`${scanId.slice(0, 8)}\`](${reportUrl})*`)
  
  return lines.join('\n')
}

/**
 * Truncate string to max length
 */
function truncate(str: string, maxLength: number): string {
  if (str.length <= maxLength) return str
  return str.slice(0, maxLength) + '...'
}

// =====================================================
// Provider API Clients
// =====================================================

/**
 * Create GitHub issue
 */
export async function createGitHubIssue(
  config: GitHubConfig,
  token: string,
  payload: TicketPayload
): Promise<CreateTicketResult> {
  try {
    const { owner, repo, labels: defaultLabels } = config
    const { title, body, labels: customLabels } = payload
    
    // Merge default and custom labels
    const allLabels = [...(defaultLabels || []), ...(customLabels || [])]
    
    const response = await fetch(
      `https://api.github.com/repos/${owner}/${repo}/issues`,
      {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Accept': 'application/vnd.github+json',
          'X-GitHub-Api-Version': '2022-11-28',
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          title,
          body,
          labels: allLabels.length > 0 ? allLabels : undefined,
        }),
      }
    )
    
    if (!response.ok) {
      const error = await response.json().catch(() => ({ message: response.statusText }))
      console.error('GitHub API error:', error)
      return {
        success: false,
        error: error.message || `GitHub API error: ${response.status}`
      }
    }
    
    const issue = await response.json()
    
    return {
      success: true,
      ticket_url: issue.html_url,
      ticket_key: String(issue.number),
    }
  } catch (error: any) {
    console.error('Failed to create GitHub issue:', error)
    return {
      success: false,
      error: error.message || 'Unknown error creating GitHub issue'
    }
  }
}

/**
 * Create Jira issue
 */
export async function createJiraIssue(
  config: JiraConfig,
  token: string,
  payload: TicketPayload
): Promise<CreateTicketResult> {
  try {
    const { host, project_key, issue_type } = config
    const { title, body } = payload
    
    // Jira uses ADF (Atlassian Document Format) for description
    // For simplicity, we'll use the legacy markdown support or plain text
    // In production, you'd want to convert Markdown to ADF
    
    const response = await fetch(
      `https://${host}/rest/api/3/issue`,
      {
        method: 'POST',
        headers: {
          'Authorization': `Basic ${Buffer.from(token).toString('base64')}`,
          'Accept': 'application/json',
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          fields: {
            project: {
              key: project_key,
            },
            summary: title,
            description: {
              type: 'doc',
              version: 1,
              content: [
                {
                  type: 'paragraph',
                  content: [
                    {
                      type: 'text',
                      text: body, // In production, convert MD to ADF
                    },
                  ],
                },
              ],
            },
            issuetype: {
              name: issue_type,
            },
          },
        }),
      }
    )
    
    if (!response.ok) {
      const error = await response.json().catch(() => ({ errorMessages: [response.statusText] }))
      console.error('Jira API error:', error)
      return {
        success: false,
        error: error.errorMessages?.[0] || `Jira API error: ${response.status}`
      }
    }
    
    const issue = await response.json()
    
    return {
      success: true,
      ticket_url: `https://${host}/browse/${issue.key}`,
      ticket_key: issue.key,
    }
  } catch (error: any) {
    console.error('Failed to create Jira issue:', error)
    return {
      success: false,
      error: error.message || 'Unknown error creating Jira issue'
    }
  }
}

/**
 * Create ticket (delegates to provider-specific function)
 */
export async function createTicket(
  provider: TicketProviderConfig,
  payload: TicketPayload
): Promise<CreateTicketResult> {
  const { provider_type, config, encrypted_token } = provider
  
  if (!encrypted_token) {
    return { success: false, error: 'No API token configured for this provider' }
  }
  
  // In production, decrypt the token here
  // For now, we'll assume it's already decrypted (or use plaintext in dev)
  const token = encrypted_token
  
  if (provider_type === 'github') {
    return createGitHubIssue(config as GitHubConfig, token, payload)
  } else if (provider_type === 'jira') {
    return createJiraIssue(config as JiraConfig, token, payload)
  } else {
    return { success: false, error: `Unknown provider type: ${provider_type}` }
  }
}
